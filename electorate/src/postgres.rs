use anyhow::Context;
use async_trait::async_trait;
use sqlx::PgPool;
use tracing::{debug, warn};

use crate::elector::{Elector, ElectorError};

/// PostgreSQL advisory lock-based leader election.
///
/// Uses PostgreSQL's advisory lock feature for distributed leader election.
/// The lock is automatically released when the connection is dropped or the
/// transaction ends.
///
/// # How it works
///
/// - Uses `pg_try_advisory_lock` to attempt non-blocking lock acquisition
/// - Lock ID is derived from a configurable key (defaults to job queue identifier)
/// - If lock is acquired, this instance is the leader
/// - Lock auto-releases on connection close (ensures failover)
/// - Safe across multiple PostgreSQL connections and servers
///
/// # Example
/// ```rust,no_run
/// use sqlx::PgPool;
/// use electorate::{Elector, PostgresAdvisoryLockElector};
///
/// # async fn example() -> anyhow::Result<()> {
/// let pool = PgPool::connect("postgresql://localhost/mydb").await?;
/// let elector = PostgresAdvisoryLockElector::new(pool, None);
///
/// if elector.is_leader().await? {
///     println!("I am the leader!");
/// }
/// # Ok(())
/// # }
/// ```
///
/// # Advisory Lock IDs
///
/// PostgreSQL advisory locks use a 64-bit integer key. We use a hash of the
/// lock name to generate a stable lock ID across instances.
#[derive(Clone)]
pub struct PostgresAdvisoryLockElector {
    pool: PgPool,
    lock_id: i64,
}

impl PostgresAdvisoryLockElector {
    /// Default lock name used for leader election
    const DEFAULT_LOCK_NAME: &'static str = "aide_de_camp_cron_scheduler";

    /// Create a new PostgreSQL advisory lock elector.
    ///
    /// # Arguments
    ///
    /// * `pool` - PostgreSQL connection pool
    /// * `lock_name` - Optional custom lock name. If None, uses default.
    ///
    /// # Lock ID Generation
    ///
    /// The lock ID is generated by hashing the lock name to create a stable
    /// 64-bit identifier. This ensures all instances use the same lock ID
    /// for coordination.
    pub fn new(pool: PgPool, lock_name: Option<&str>) -> Self {
        let name = lock_name.unwrap_or(Self::DEFAULT_LOCK_NAME);
        let lock_id = Self::hash_lock_name(name);

        debug!(
            lock_id,
            lock_name = name,
            "Initialized PostgreSQL advisory lock elector"
        );

        Self { pool, lock_id }
    }

    /// Hash a lock name to generate a stable 64-bit lock ID.
    ///
    /// Uses a simple but stable hash function. In production, you might want
    /// to use a proper hash function from a crate like `seahash` or similar.
    fn hash_lock_name(name: &str) -> i64 {
        // Simple FNV-1a hash
        let mut hash: u64 = 14695981039346656037;
        for byte in name.bytes() {
            hash ^= byte as u64;
            hash = hash.wrapping_mul(1099511628211);
        }
        // Convert to i64 (PostgreSQL expects signed int)
        hash as i64
    }
}

#[async_trait]
impl Elector for PostgresAdvisoryLockElector {
    async fn is_leader(&self) -> Result<bool, ElectorError> {
        // First, try to acquire the lock non-blocking
        let acquired: bool = sqlx::query_scalar("SELECT pg_try_advisory_lock($1)")
            .bind(self.lock_id)
            .fetch_one(&self.pool)
            .await
            .context("Failed to attempt advisory lock acquisition")?;

        if acquired {
            debug!(
                lock_id = self.lock_id,
                "Acquired advisory lock, I am the leader"
            );
            return Ok(true);
        }

        // Lock not acquired, check if we already hold it
        // Query pg_locks to see if our session has the lock
        let has_lock: bool = sqlx::query_scalar(
            "SELECT EXISTS(
                SELECT 1 FROM pg_locks
                WHERE locktype = 'advisory'
                AND classid = $1
                AND objid = $2
                AND pid = pg_backend_pid()
            )",
        )
        .bind((self.lock_id >> 32) as i32) // classid is upper 32 bits
        .bind(self.lock_id as i32) // objid is lower 32 bits
        .fetch_one(&self.pool)
        .await
        .context("Failed to check existing advisory lock status")?;

        if has_lock {
            debug!(lock_id = self.lock_id, "Already holding advisory lock");
        } else {
            debug!(
                lock_id = self.lock_id,
                "Advisory lock held by another instance"
            );
        }

        Ok(has_lock)
    }

    async fn release_leadership(&self) -> Result<(), ElectorError> {
        let released: bool = sqlx::query_scalar("SELECT pg_advisory_unlock($1)")
            .bind(self.lock_id)
            .fetch_one(&self.pool)
            .await
            .context("Failed to release advisory lock")?;

        if released {
            debug!(lock_id = self.lock_id, "Released advisory lock");
        } else {
            warn!(
                lock_id = self.lock_id,
                "Attempted to release advisory lock we don't hold"
            );
        }

        Ok(())
    }
}

impl std::fmt::Debug for PostgresAdvisoryLockElector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("PostgresAdvisoryLockElector")
            .field("lock_id", &self.lock_id)
            .finish()
    }
}
